%!TEX TS-program = xelatex

% Шаблон документа LaTeX создан в 2018 году
% Алексеем Подчезерцевым
% В качестве исходных использованы шаблоны
% 	Данилом Фёдоровых (danil@fedorovykh.ru) 
%		https://www.writelatex.com/coursera/latex/5.2.2
%	LaTeX-шаблон для русской кандидатской диссертации и её автореферата.
%		https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template

\documentclass[a4paper,14pt]{article}

\input{data/preambular.tex}
\begin{document} % конец преамбулы, начало документа
\input{data/title.tex}
\setcounter{page}{2} % нумерация

\renewcommand\contentsname{\centering {\normalsize Содержание}}
\tableofcontents
\newpage

\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}

Используя перегрузку операторов (\textit{operator}) разработать стандартную арифметику объектов, включающую арифметические действия над объектами и целыми (вещественными, строками – в зависимости от
вида объектов), присваивание, ввод и вывод в стандартные потоки, приведение к базовому типу данных, извлечение и обновление отдельных элементов (например, коэффициентов матрицы или символов строки). По возможности организовать операции в виде конвейера значений, с результатом (новым объектом) и сохранением значений входных операндов. Для выбора варианта заданий использовать перечень классов из лабораторной работы №1: целое произвольной длины во внешней форме представления в виде строки символов-цифр.

\newpage

\section{Основная часть}
\subsection{Общая идея решения задачи}
В лабораторной работе №2 был использован класс, разработанный в лабораторной работе №1, его методы частично реализовывают задание.
Для решения задачи были использованы перегрузки операторов: \textit{operator>>}, \textit{operator*}, \textit{operator/}, \textit{operator*=}, \textit{opeartor/=}, \textit{operator string()}, \textit{operator[]}, \textit{operator()}.
Был доработан алгоритм сравнения и добавлены \textit{operator>}, \textit{operator>=}, \textit{operator<=}. Добавлена функция \textit{Abs()}.
\subsection{Структура и принципы действия}
Ввод в стандартный поток был реализован с помощью перегрузки дружественного оператора \textit{operator>>}, где происходило считывание строки произвольной длины с учетом знака. Также появился конструктор по умолчанию. Теперь с помощью этой конструкции можно удобно проинициализировать \textit{BigInt}.

Для приведения к базовому типу данных (строке), была использована перегрузка константного оператора \textit{operator string()}. Оператор возвращает строковое представление числа с учетом знака числа.

Для извлечения отдельных элементов \textit{BigInt} был перегружен константный оператор \textit{operator[]}, он принимает на вход любое целое число и находит символ с нужным индексом в замыкании длины числа.

Для частичного обновления объекта была использована перегрузка оператора \textit{operator()}. Этот оператор принимает на вход 2 числа: позицию, в которой нужно изменить цифру, и символ-цифру, на которую нужно заменить исходный символ. Позиция также высчитывается по замыканию длины числа. Если полученный символ не цифра, то выбрасывается исключение.

Была дополнена стандартная арифметика объектов: помимо сложения и вычитания появилось умножение и целочисленное деление. 
Для реализации алгоритма умножения был использован вектор с длиной, равной сумме длин умножаемых чисел + 1, проинициализированный нулями. Далее было 2 вложенных цикла, в которых произведения элементов 2-х чисел прибавляются к элементу вектора с соответствующим индексом. В следующем цикле мы избавлялись от переполнения разряда, и переносили избыток с следующий разряд, и затем удаляли лишние нули. Также в алгоритме учитывался знак 2-х сомножителей. Также была включена проверка умножения на ноль.

Алгоритм деления был реализован, как деление столбиком. Бралась первая часть делимого с длиной делителя. Из этой части необходимое количество раз вычитался делитель, а это количество записывалось в частное. Затем к остатку от разности добавлялось следующая цифра делимого. Все это повторялось, пока не пройдем все число. Затем дробная часть просто отбрасывалась. Отдельно были рассмотрены деление на ноль, при котором выбрасывалось исключение и случай, когда делимое меньше делителя, в этом случае результат 0. Для этого алгоритма активно использовались перегруженные операторы сравнения, константная функция \textit{Abs}, которая возвращает модуль числа, константная функция проверки числа на нулевое значение \textit{isZero}.

Дополнительно с помощью этих алгоритмов были перегружены операторы \textit{operator*=}, \textit{opeartor/=}.

\subsection{Процедура получения исполняемых программных модулей}
Программный код был скомпилирован с среде \textit{Visual Studio 2017}. Компиляция раздельная. Код программы содержится в разных файлах. Никаких дополнительных ключей не добавлялось, использовались ключи, которые добавляются по умолчанию.
\subsection{Результаты тестирования}
Для тестирования программы был применен механизм UnitTest, все тесты были пройдены успешно.
Также в функции \textit{main} файла Main.cpp представлено дополнительное тестирование. Ожидаемый вывод функции: 
\begin{verbatim}
123
123

129934811447123020117172145698572
-51487004
-51487004
123 3 2 1 3
alarm! division by zero
129 9 2 1 9
-15867
1
\end{verbatim}

\newpage
\setcounter{figure}{1} 
\setcounter{section}{1} 
\setcounter{subsection}{1} 

\begin{center}
	\section*{Приложение А}
	полный код программы
	\addcontentsline{toc}{section}{Приложение А}
	
\end{center}

\renewcommand{\subsection}{\Asbuk{section}.\arabic{subsection}}
\setcounter{subsection}{1} 
\textbf{\subsection{  - Main.cpp}}
\addcontentsline{toc}{subsection}{Main.cpp}
\lstinputlisting[language=C++]{../BigInt/Main.cpp}

\setcounter{subsection}{2} 
\textbf{\subsection{  - BigInt.h}}
\addcontentsline{toc}{subsection}{BigInt.h}
\lstinputlisting[language=C++]{../BigInt/BigInt.h}

\setcounter{subsection}{3} 
\textbf{\subsection{  - Unittest1.cpp}}
\addcontentsline{toc}{subsection}{Unittest1.cpp}
\lstinputlisting[language=C++]{../UnitTest1/unittest1.cpp}


\end{document} % конец документа
